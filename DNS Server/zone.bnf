;   name = definition
;      The name of a rule is simply the name itself (without any
;      enclosing "<" and ">") and is separated from its definition by the
;      equal "=" character. White space is only significant in that
;      indentation of continuation lines is used to indicate a rule
;      definition that spans more than one line. Certain basic rules are
;      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle
;      brackets are used within definitions whenever their presence will
;      facilitate discerning the use of rule names.
;
;   "literal"
;      Quotation marks surround literal text. Unless stated otherwise,
;      the text is case-insensitive.
;
;   rule1 | rule2
;      Elements separated by a bar ("|") are alternatives, e.g., "yes |
;      no" will accept yes or no.
;
;   (rule1 rule2)
;      Elements enclosed in parentheses are treated as a single element.
;      Thus, "(elem (foo | bar) elem)" allows the token sequences "elem
;      foo elem" and "elem bar elem".
;
;   *rule
;      The character "*" preceding an element indicates repetition. The
;      full form is "<n>*<m>element" indicating at least <n> and at most
;      <m> occurrences of element. Default values are 0 and infinity so
;      that "*(element)" allows any number, including zero; "1*element"
;      requires at least one; and "1*2element" allows one or two.
;   [rule]
;      Square brackets enclose optional elements; "[foo bar]" is
;      equivalent to "*1(foo bar)".

line		= ( directive | record | blank ) LWS [ comment ] newline

directive	= "$" ( origin | ttl )
origin		= "ORIGIN" 1*( WS ) FQDN
ttl			= "TTL" 1*( WS ) ( ttl-value | 1*( 1*( DIGIT ) ttl-unit ) )
ttl-value	= 1*( DIGIT )
ttl-unit	= "w" | "d" | "h" | "m" | "s"

;	syntactically <rdata> is the only required field, semantically the preceeding record must provide values for <name>, <class> and <type> or the zone is invalid
record		= ( LWS | ( name 1*( WS ) ) ) [ ttl-value 1*( WS ) ] [ class 1*( WS ) ] [ type 1*( WS ) ] rdata

;	incomplete list of class types, but we're unlikely to need to return Chaosnet or Hesiod class records
class		= "IN"

;	incomplete list of record types, but we're unlikely to need to return those unlisted, support should be easy to add if need be
type		= "A" | "AAAA" | "MX" | "NS" | "PTR" | "SOA" | "SRV" | "TXT"

;	rdata can be split across multiple lines with each line optionally carrying a comment before newline
rdata		= ( "(" 1*( data [ comment ] [ newline ] ) ")" ) | data
;	data can be multiple runs of whitespace separated quoted-data, or a single run of inner-data optionally across multiple lines with whitespace ignored
data		= ( quoted-data *( WS quoted-data ) ) | 1*( inner-data LWS )
;	quoted-data can contain whitespace, maximum length of quoted-data is 255 characters
quoted-data = ( <"> *( inner-data | WS | quoted-pair ) <"> )
;	if data for a specific resource contains on of the excluded literal characters it must use quoted-data
inner-data	= <any CHAR except EXCLUDED>
EXCLUDED	= <"> | ";" | WS | "(" | ")"
quoted-pair	= "\" CHAR

blank		= LWS

;	either @ to refer to the origin, or a domain name which has the origin appended to make it fully qualified, or a fully qualified domain name, both with an optional wildcard prefix
name		= "@" | ( [ "*" "." ] ( DN | FQDN ) )
DN			= label *( "." label )
FQDN		= 1*( label "." )
label		= 1*( ALPHA | DIGIT | "-" )
CHAR        = <any US-ASCII character (octets 0 - 127)>
UPALPHA     = <any US-ASCII uppercase letter "A".."Z">
LOALPHA     = <any US-ASCII lowercase letter "a".."z">
ALPHA       = UPALPHA | LOALPHA
DIGIT       = <any US-ASCII digit "0".."9">

comment		= ";" *TEXT
TEXT        = <any OCTET except CTLs, but including LWS>
CTL         = <any US-ASCII control character (octets 0 - 31) and DEL (127)>

CR          = <US-ASCII CR, carriage return (13)>
newline		= ( CR LF ) | LF
;	LWS is implicitly optional, minimum of 0 maximum of infinite
LWS			= *( WS )
WS			= SP | HT
SP          = <US-ASCII SP, space (32)>
HT          = <US-ASCII HT, horizontal-tab (9)>
